! This program verifies the acceleration module by placing atoms diagonally to ensure 
! correct force projection on X, Y, and Z axes in a quantitative way

! NOTE: Structured and partially generated by ChatGPT

program test_acceleration_mod_2

  use acceleration_mod
  implicit none
  integer, parameter :: Natoms = 2
  double precision :: coord(Natoms,3), mass(Natoms), distance(Natoms,Natoms), acceleration(Natoms,3)
  
  ! Variables for manual verification calculation
  double precision :: epsilon = 1.0d0, sigma = 1.0d0
  double precision :: r2, inv_r2, inv_r6, inv_r12, scalar_force, expected_acc
  double precision :: tol = 1.0d-8

  write(*,*) "=== TEST MODULE: ACCELERATION (3D Check) ==="

  ! 1. Initialization

  coord = 0.0d0
  acceleration = 0.0d0
  mass = 1.0d0 
  distance = 0.0d0


  ! 2. 3D Scenario setup

  ! Atom 1 at (0,0,0)
  ! Atom 2 at (1,1,1) -> Diagonal position
  coord(2,1) = 1.0d0
  coord(2,2) = 1.0d0
  coord(2,3) = 1.0d0
  
  ! Distance squared r^2 = 1^2 + 1^2 + 1^2 = 3.0
  r2 = 3.0d0
  distance(1,2) = sqrt(r2)
  distance(2,1) = sqrt(r2)


  ! 3. Execute the subroutine

  call compute_acc(Natoms, coord, mass, distance, epsilon, sigma, acceleration)


  ! 4. MANUAL Calculation of expected result (LJ Formula)
  ! F = 24*epsilon * (1/r^2) * [ 2*(sigma/r)^12 - (sigma/r)^6 ] * vector_r
  
  ! Step-by-step calculation
  inv_r2  = 1.0d0 / r2              ! 1 / r^2
  inv_r6  = inv_r2 * inv_r2 * inv_r2 
  inv_r12 = inv_r6 * inv_r6
  
  ! Scalar part of the Force (magnitude term without direction)
  scalar_force = (24.0d0 * epsilon * inv_r2) * (2.0d0 * inv_r12 - inv_r6)
  
  ! For Atom 1, the distance vector is (x1 - x2) = (0 - 1) = -1.0
  ! Since it is symmetric at (1,1,1), the vector is (-1, -1, -1)
  ! Force in X = scalar_force * (-1.0)
  ! Acceleration = Force / Mass (mass is 1.0)
  expected_acc = scalar_force * (-1.0d0) / mass(1)


  ! 5. Verification

  write(*,*) "--- Results ---"
  write(*,*) "Calculated Acc X:", acceleration(1,1)
  write(*,*) "Expected Acc X  :", expected_acc
  write(*,*) " "

  ! Check X
  if (abs(acceleration(1,1) - expected_acc) < tol) then
     write(*,*) "[OK] X Component correct."
  else
     write(*,*) "[FAIL] X Component incorrect."
  end if

  ! Check Y (must be equal to X due to symmetry)
  if (abs(acceleration(1,2) - expected_acc) < tol) then
     write(*,*) "[OK] Y Component correct."
  else
     write(*,*) "[FAIL] Y Component incorrect."
  end if

  ! Check Z
  if (abs(acceleration(1,3) - expected_acc) < tol) then
     write(*,*) "[OK] Z Component correct."
  else
     write(*,*) "[FAIL] Z Component incorrect."
  end if

end program test_acceleration_mod_2
